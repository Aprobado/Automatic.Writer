//
//  Parser.swift
//  AutomaticWriter
//
//  Created by Raphael on 30.01.15.
//  Copyright (c) 2015 HEAD Geneva. All rights reserved.
//

import Foundation

class Parser : NSObject {
    
    class var htmlOpeningHeader:String {
        return "<!doctype html>\n<html lang=\"fr\">\n<head>\n\t<!--file generated by AutomaticWriter-->\n\t<meta charset=\"utf-8\" />\n"
    }
    class var htmlClosingHeader:String {
        return "</head>\n"
    }
    class var defaultTitle:String { return "No Title" }
    class var htmlDefaultEnd:String { return "\n</html>" }
    
    class func automatFileToHtml(file:String) -> String? {
        if NSFileManager.defaultManager().fileExistsAtPath(file) {
            var error:NSError?
            let text = String(contentsOfFile: file, encoding: NSUTF8StringEncoding, error: &error)
            if let actualError = error {
                println("\(self.className()) - error while retrieving content of file at path \(file)")
            } else {
                // we got the text all right
                return automatToHtmlWithString(text!)
            }
        }
        return nil
    }
    
    class func automatToHtmlWithString(automatText:String) -> String? {
        
        // MARK: * get tokens from highlighter
        var highlighter = Highlighter()
        let highlights = highlighter.findHighlightsInRange(NSMakeRange(0, countElements(automatText)), forText: automatText)
        
        // MARK: * convert them into ConvertibleTokens that contain the string they're replacing
        var titles = [ConvertibleToken]()
        var cssImports = [ConvertibleToken]()
        var jsImports = [ConvertibleToken]()
        var jsDeclarations = [ConvertibleToken]()
        var openingTags = [HighlightToken]()
        var closingTags = [HighlightToken]()
        var events = [ConvertibleToken]()
        var jsLines = [ConvertibleToken]()
        var twines = [ConvertibleToken]()
        var comments = [ConvertibleToken]()
        var tokens = [ConvertibleToken]()
        
        for highlight in highlights {
            let token = ConvertibleToken(_ranges: highlight.ranges, _type: highlight.type, _text: automatText)
            switch highlight.type {
            case .TITLE:
                titles += [token]
            case .CSSIMPORT:
                cssImports += [token]
            case .JSIMPORT:
                jsImports += [token]
            case .JSDECLARATION:
                jsDeclarations += [token]
            case .OPENINGBLOCKTAG, .OPENINGINLINETAG:
                openingTags += [highlight]
            case .CLOSINGBLOCKTAG, .CLOSINGINLINETAG:
                closingTags += [highlight]
            case .EVENT:
                events += [token]
            case .JS:
                jsLines += [token]
            case .TWINE:
                twines += [token]
            case .COMMENT:
                comments += [token]
            default:
                tokens += [token]
            }
        }
        
        let completeTagTokens = tagHighlightsToConvertibleTokens(openingTags, closingTags: closingTags, withText: automatText)
        
        // MARK: * Header construction
        var convertedText = automatText
        
        var htmlHeader = htmlOpeningHeader
        for token in titles {
            htmlHeader += convertTitle(token)
        }
        for token in cssImports {
            htmlHeader += convertCssImport(token)
        }
        for token in jsImports {
            htmlHeader += convertJsImport(token)
        }
        htmlHeader += "\t<script>\n"
        for token in jsDeclarations {
            htmlHeader += "\(token.captureGroups[0])\n"
        }
        htmlHeader += "\t</script>\n"
        htmlHeader += htmlClosingHeader
        
        // MARK: * Body construction
        convertedText = replaceTagTokensInText(convertedText, tokens: completeTagTokens)
        
        convertedText = textByRemovingTokensFromText(convertedText, tokens: titles+cssImports+jsImports+jsDeclarations)
        //println(htmlHeader)
        //println(convertedText)
        
        convertedText = replaceJsLinesTokensInText(convertedText, tokens: jsLines)
        
        convertedText = replaceTwineTokensInText(convertedText, tokens: twines)
        
        convertedText = textByRemovingTokensFromText(convertedText, tokens: comments);
        
        let eventsText = convertEventTokens(events)
        convertedText = textByRemovingTokensFromText(convertedText, tokens: events);
        
        // mark down at the end
        convertedText = MMMarkdown.HTMLStringWithMarkdown(convertedText, error: nil)
        
        return "\(htmlHeader)<body>\n\(convertedText)\(eventsText)</body>\n</html>"
        
        /*
        //println("--------------------")
        
        // get a reduced text and the html header
        var (reducedText, htmlHeader) = constructHtmlHeaderForText(automatText)
        
        // get functions attached to body
        var events = ""
        (reducedText, events) = extractEventAssignments(reducedText)
        //var bodyFunctions = ""
        //(reducedText, bodyFunctions) = extractBodyFunctions(reducedText)
        
        // replace Twine links
        reducedText = replaceTwineOccurencesByHTMLLinks(reducedText)
        
        // replace function calls
        reducedText = replaceFunctionCalls(reducedText)
        
        // replace comments
        reducedText = replaceComments(reducedText)
        
        // convert ids and classes to HTML tags with ids and classes
        reducedText = convertIdsAndClasses(reducedText)
        
        reducedText = MMMarkdown.HTMLStringWithMarkdown(reducedText, error: nil)
        
        //return "\(htmlHeader)<body\(bodyFunctions)>\n\(reducedText)\n</body>\n</html>"
        return "\(htmlHeader)<body>\n\(reducedText)\(events)</body>\n</html>"
        */
    }
    
    // ==================================================
    // MARK: ConvertibleToken converters
    class func convertTitle(token:ConvertibleToken) -> String {
        return "\t<title>\(token.captureGroups[1])</title>\n"
    }
    
    class func convertCssImport(token:ConvertibleToken) -> String {
        return "\t<link rel=\"stylesheet\" type=\"text/css\" href=\"css/\(token.captureGroups[1])\">\n"
    }
    
    class func convertJsImport(token:ConvertibleToken) -> String {
        return "\t<script src=\"lib/\(token.captureGroups[1])\"></script>\n"
    }
    
    class func convertEventTokens(tokens:[ConvertibleToken]) -> String {
        // structure of event:
        // for .hidden::first-letter<click=”show(delay)”> // show with delay
        // $1 = selector	(.hidden::first-letter)
        // $2 = event		(click)
        // $3 = function	(show)
        // $4 = parameters	(delay)
        // $5 = comment	( show with delay)
        if tokens.isEmpty { return "" }
        
        var result = "<script>\n"
        for token in tokens {
            let selector = token.captureGroups[1]
            let event = token.captureGroups[2]
            let function = token.captureGroups[3]
            result += "\taddEvent('\(event)', \(function), '\(selector)');\n"
        }
        result += "</script>\n"
        return result
    }
    
    // ==================================================
    // MARK: ConvertibleTokens for tags from Highlights
    class func tagHighlightsToConvertibleTokens(openingTags:[HighlightToken], closingTags:[HighlightToken], withText text:String) -> [ConvertibleToken] {
        var tokens = [ConvertibleToken]()
        for var i = 0; i < countElements(openingTags); i++ {
            let lengthOfCompleteTag = closingTags[i].ranges[0].location + closingTags[i].ranges[0].length - openingTags[i].ranges[0].location
            let rangeOfCompleteTag = NSMakeRange(openingTags[i].ranges[0].location, lengthOfCompleteTag)
            var type = (openingTags[i].type == HighlightType.OPENINGBLOCKTAG && closingTags[i].type == HighlightType.CLOSINGBLOCKTAG) ? HighlightType.BLOCKTAG : HighlightType.INLINETAG
            tokens += [ConvertibleToken(_ranges: [rangeOfCompleteTag]+openingTags[i].ranges+closingTags[i].ranges, _type: type, _text: text)]
        }
        return tokens
    }
    
    // ==================================================
    // MARK: Remove ConvertibleTokens occurences from text
    class func textByRemovingTokensFromText(text:String, tokens:[ConvertibleToken]) -> String {
        var tempText = text
        for token in tokens {
            tempText = tempText.stringByReplacingOccurrencesOfString(token.captureGroups[0], withString: "", options: nil, range: Range(start:tempText.startIndex, end:tempText.endIndex))
        }
        return tempText
    }
    
    // ==================================================
    // MARK: Replace ConvertibleTokens in text
    class func replaceTagTokensInText(text:String, tokens:[ConvertibleToken]) -> String {
        // structure of a tag token:
        // $0: full text to replace
        // $1: Opening tag
        // $2: prefix (# or .)
        // $3: class or id name
        // $4: closing tag
        // $5: closing tag function attachment
        
        // retains conversions of tags with ranges.
        // will be sorted by range.location smaller -> bigger before replacement in text
        var newTokens = [ConvertibleToken]()
        
        var tempText = text
        for token in tokens {
            // get the string bits we need
            let tag = token.type == HighlightType.BLOCKTAG ? "div" : "span"
            let selector = token.captureGroups[2] == "#" ? "id" : "class"
            let name = token.captureGroups[3]
            var function = ""
            if token.captureGroups[5] != "" {
                function += " \(token.captureGroups[5])"
            }
            
            // create the opening and closing tags
            let htmlOpeningTag = "<\(tag) \(selector)=\"\(name)\"\(function)>"
            let htmlClosingTag = "</\(tag)>"
            
            // range is range of text that needs replacement
            let opType = token.type == HighlightType.BLOCKTAG ? HighlightType.OPENINGBLOCKTAG : HighlightType.OPENINGINLINETAG
            var openTok = ConvertibleToken(_ranges: [token.ranges[1]], _type: opType, _text: text)
            let clType = token.type == HighlightType.BLOCKTAG ? HighlightType.CLOSINGBLOCKTAG : HighlightType.CLOSINGINLINETAG
            var closeTok = ConvertibleToken(_ranges: [token.ranges[4]], _type: clType, _text: text)
            // capture group is modified to be the text we replace the range with
            openTok.captureGroups = [htmlOpeningTag]
            closeTok.captureGroups = [htmlClosingTag]
            
            newTokens += [openTok, closeTok]
        }
        
        // sort the tokens to replace them one after the other in location order
        newTokens.sort({$0.ranges[0].location < $1.ranges[0].location})
        var delta = 0
        
        // at the same time we're replacing tags, we retain where the divs are to convert their innerText markdown
        var divOpenings = [Int]() // location of div openings
        var pairs = [Pair]()    // pairs of Ints with start.location and end.location of what's INSIDE a <div> tag
                                // the loop enters the divs inner first, outer last in the pairs
        for token in newTokens {
            let tokenStartLocation = token.ranges[0].location + delta
            let startRange = advance(tempText.startIndex, tokenStartLocation)
            let endRange = advance(startRange, token.ranges[0].length)
            var range = Range<String.Index>(start: startRange, end: endRange)
            tempText = tempText.stringByReplacingCharactersInRange(range, withString: token.captureGroups[0])
            
            delta += countElements(token.captureGroups[0]) - token.ranges[0].length
            
            if token.type == HighlightType.OPENINGBLOCKTAG {
                divOpenings += [token.ranges[0].location + delta + token.ranges[0].length] // get the new opening location+length
            } else if token.type == HighlightType.CLOSINGBLOCKTAG {
                let divClosing = tokenStartLocation
                pairs += [Pair(_a: divOpenings.last!, _b: divClosing)]
                divOpenings.removeLast()
            }
        }
        
        // get the innerText of each div
        var divContents = [String]()
        for pair in pairs {
            println(pair)
            let startRange = advance(tempText.startIndex, pair.a as Int)
            let endRange = advance(tempText.startIndex, pair.b as Int)
            divContents += [tempText.substringWithRange(startRange..<endRange)]
        }
        
        // reverse the order to have outer first, inner last
        divContents = divContents.reverse()
        for content in divContents {
            // replace content by a markdown converted content
            let convertedContent = MMMarkdown.HTMLStringWithMarkdown(content, error: nil)
            tempText = tempText.stringByReplacingOccurrencesOfString(content, withString: convertedContent)
        }
        
        // return the modified text
        return tempText
    }
    
    class func replaceJsLinesTokensInText(text:String, tokens:[ConvertibleToken]) -> String {
        var tempText = text
        for token in tokens {
            let replacingString = "<script>\n\(token.captureGroups[0])\n</script>\n"
            tempText = tempText.stringByReplacingOccurrencesOfString(token.captureGroups[0], withString: replacingString, options: NSStringCompareOptions.LiteralSearch, range: Range(start: tempText.startIndex, end: tempText.endIndex))
        }
        return tempText
    }
    
    class func replaceTwineTokensInText(text:String, tokens:[ConvertibleToken]) -> String {
        // structure of a twine token:
        // $1 = content
        // $2 = link
        // $3 = executable code (variable declarations, etc)
        var tempText = text
        for token in tokens {
            var replacingString = "<a href=\"\(token.captureGroups[2])\">\(token.captureGroups[1])</a>"
            if token.captureGroups[3] != "" {
                replacingString += "<script>\(token.captureGroups[3])</script>"
            }
            tempText = tempText.stringByReplacingOccurrencesOfString(token.captureGroups[0], withString: replacingString, options: NSStringCompareOptions.LiteralSearch, range: Range(start: tempText.startIndex, end: tempText.endIndex))
        }
        return tempText
    }
    
    // MARK: ==================================================
    // MARK: Old functions
    // MARK: ==================================================
    
    // ==================================================
    // MARK: find matches for regular expressions
    
    class func getOccurencesOfRegularExpression(expression:String, inString string:String) -> [RegexMatch]? {
        return getOccurencesOfRegularExpression(expression, inString: string, withRange: NSMakeRange(0, countElements(string)))
    }
    
    class func getOccurencesOfRegularExpression(expression:String, inString string:String, withRange range:NSRange) -> [RegexMatch]? {
        var error:NSError?
        let regex = NSRegularExpression(pattern: expression, options: NSRegularExpressionOptions.CaseInsensitive, error: &error)
        if let actualError = error {
            println("\(self.className()) - error while trying to find regex \"\(expression)\" in string")
        }
        if let actualRegex = regex {
            var matches:[RegexMatch] = [RegexMatch]()
            actualRegex.enumerateMatchesInString(string, options: NSMatchingOptions.ReportProgress, range: range) {
                match, flags, stop in
                if (match == nil) {
                    return
                }
                var regexMatchTokens:[Token] = [Token]()
                
                // for each match, create a list of tokens with the concerned string and its range
                for var i = 0; i < match.numberOfRanges; ++i {
                    let matchRange = match.rangeAtIndex(i)
                    if matchRange.location > (countElements(string) - 1) {
                        regexMatchTokens += [Token(_string: "", _range: NSMakeRange(0, 0))]
                        continue
                    }
                    let start = advance(string.startIndex, matchRange.location)
                    let end = advance(string.startIndex, matchRange.location+matchRange.length)
                    var range = Range<String.Index>(start: start, end: end)
                    regexMatchTokens += [Token(_string: string.substringWithRange(range), _range: matchRange)]
                }
                
                matches += [RegexMatch(groups: regexMatchTokens)]
            }
            
            return matches
        }
        
        return nil
    }
    
    // =======================================================
    // MARK: replacing functions
    
    class func eraseMatchFromText(text:String, matches:[RegexMatch]?) -> String {
        var tempText = text
        if let actualMatches = matches {
            for match in actualMatches {
                tempText = eraseTokenFromText(tempText, token: match.groups[0])
            }
        }
        return tempText
    }
    
    class func eraseTokenFromText(text:String, token:Token) -> String {
        var tempText = text
        tempText = tempText.stringByReplacingOccurrencesOfString(token.string, withString: "", options: nil, range: Range(start:tempText.startIndex, end:tempText.endIndex))
        return tempText
    }
    
    // =======================================================
    // MARK: stuff that is inserted into the <head> tag
    
    /// Construct Html header <head></head> with all the elements found in the .automat file
    ///
    /// :returns: string[0]: the automatText without the tags we found | string[1]:the html header
    class func constructHtmlHeaderForText(text:String) -> (reducedText:String, htmlHeader:String) {
        // we remove matches from reducedText everytime we find one
        var reducedText = text
        
        // Open header tag
        var htmlHeader = htmlOpeningHeader
        
        // for title tag in header, use (?:(?<=\n)|(?<=\A)):: (.+?)(?:(?=\n)|(?=\Z)) // we use only the first match... one title per file
        var titles = getOccurencesOfRegularExpression("(?:(?<=\\n)|(?<=\\A)):: (.+?)(?:(?=\\n)|(?=\\Z))", inString: text)
        htmlHeader += getHtmlTitleWithMatches(titles)
        reducedText = eraseMatchFromText(reducedText, matches: titles)
        
        // for css imports, use (?:(?<=\n)|(?<=\A))#import "([^"]+?.css)" ?((?://)?.*?)?(?:(?=\n)|(?=\Z))
        var cssImports = getOccurencesOfRegularExpression("(?:(?<=\\n)|(?<=\\A))#import \"([^\"]+?.css)\" ?((?://)?.*?)?(?:(?=\\n)|(?=\\Z))", inString: reducedText)
        htmlHeader += getHtmlCssLinkWithMatches(cssImports)
        reducedText = eraseMatchFromText(reducedText, matches: cssImports)
        
        // for javascript imports, use (?:(?<=\n)|(?<=\A))#import "([^"]+?.js)" ?((?://)?.*?)?(?:(?=\n)|(?=\Z))
        var javascriptImports = getOccurencesOfRegularExpression("(?:(?<=\\n)|(?<=\\A))#import \"([^\"]+?.js)\" ?((?://)?.*?)?(?:(?=\\n)|(?=\\Z))", inString: reducedText)
        htmlHeader += getHtmlJsLinkWithMatches(javascriptImports)
        reducedText = eraseMatchFromText(reducedText, matches: javascriptImports)
        
        // for var declaration, use (?:(?<=\n)|(?<=\A))(var \w+? ?= ?[^;\n]+?; ?(?://.*?)?)(?:(?=\n)|(?=\Z))
        var varInsertion = getOccurencesOfRegularExpression("(?:(?<=\\n)|(?<=\\A))(var \\w+? ?= ?[^;\\n]+?; ?(?://.*?)?)(?:(?=\\n)|(?=\\Z))", inString: reducedText)
        let variables = getJsVariablesWithMatches(varInsertion)     // this will be inserted in htmlHeader below
        reducedText = eraseMatchFromText(reducedText, matches: varInsertion)
        
        // for javascript function declaration, use (?:(?<=\n)|(?<=\A))(var \w+? ?= ?function\(.*?\) ?\{ ?(?://.*?)?)(?:(?=\n)|(?=\Z))
        var functionInsertion = getOccurencesOfRegularExpression("(?:(?<=\\n)|(?<=\\A))(var \\w+? ?= ?function\\(.*?\\) ?\\{ ?(?://.*?)?)(?:(?=\\n)|(?=\\Z))", inString: reducedText)
        //println("function insertion found: \(functionInsertion)")
        
        var functions = ""      // this will be inserted in htmlHeader below
        
        if let actualFunctions = functionInsertion {
            var tokens = [Token]()
            for function in actualFunctions {
                let tok = completeTokenForJavascriptFunction(function.groups[1], inText: reducedText)
                //println(tok)
                if let actualToken = tok {
                    //println("token found: \(actualToken)")
                    functions += "\n\(actualToken.string)\n"
                    tokens += [actualToken]
                }
            }
            for token in tokens {
                reducedText = eraseTokenFromText(reducedText, token: token)
            }
        }
        
        //var events = ""
        //(reducedText, events) = extractEventAssignments(reducedText)
        
        // if we found at least one variable or one function declaration, insert a script tag with what we found
        if variables != "" || functions != "" {
            htmlHeader += "\t<script>\n"    // open script tag
            htmlHeader += variables         // insert variables
            htmlHeader += functions         // insert functions
            //htmlHeader += events            // insert events assignments
            htmlHeader += "\t</script>\n"   // close script tag
        }
        
        // Close the header tag
        htmlHeader += htmlClosingHeader
        
        return (reducedText, htmlHeader)
    }
    
    /// :returns: <title>Actual Title</title>
    class func getHtmlTitleWithMatches(matches:[RegexMatch]?) -> String {
        var title = defaultTitle
        if let actualMatches = matches {
            if countElements(actualMatches) > 0 {
                title = actualMatches[0].groups[1].string
            }
        }
        return "\t<title>\(title)</title>\n"
    }
    
    /// :returns: <link rel="stylesheet" type="text/css" href="mystyle.css"> for each match
    class func getHtmlCssLinkWithMatches(matches:[RegexMatch]?) -> String {
        var result = ""
        if let actualMatches = matches {
            for match in actualMatches {
                result += "\t<link rel=\"stylesheet\" type=\"text/css\" href=\"css/\(match.groups[1].string)\">\n"
            }
        }
        return result
    }
    
    /// :returns: <script src="myscripts.js"></script> for each match
    class func getHtmlJsLinkWithMatches(matches:[RegexMatch]?) -> String {
        var result = ""
        if let actualMatches = matches {
            for match in actualMatches {
                result += "\t<script src=\"lib/\(match.groups[1].string)\"></script>\n"
            }
        }
        return result
    }
    
    /// :returns: the lines "var myVar = value;" for each match
    class func getJsVariablesWithMatches(matches:[RegexMatch]?) -> String {
        var result = ""
        if let actualMatches = matches {
            for match in actualMatches {
                result += "\t\t\(match.groups[1].string)\n"
            }
        }
        return result
    }
    
    // =======================================================
    // MARK: functions that extract (find and erase) from text and return a converted result
    
    class func extractEventAssignments(text:String) -> (String, String) {
        // TODO: modify the logic to be able to attach more than one event or function. This will lead to unexpected results as it is.
        
        // using (?:(?<=^)) *([^\n\t\{\}\\\/\?!<]*?) *< *([\w]+) *= *"?([\w]+) *(?:\(([\w, ]*)\))?"? *>[ \t]*(?://(.*?))?(?:(?=\n)|(?=\Z))
        
        var result = text
        var events = ""
        
        //let expression = "(?:(?<=\\n)|(?<=\\A))<([^\\n]+)>"
        let expression = "(?:(?<=\\n)|(?<=\\A)) *([^\\n\\t\\{\\}\\\\\\/\\?!<]*?) *< *([\\w]+) *= *\"?([\\w]+) *(?:\\(([\\w, ]*)\\))?\"? *>[ \\t]*(?://(.*?))?(?:(?=\\n)|(?=\\Z))"
        var eventAssignments = getOccurencesOfRegularExpression(expression, inString: text)
        //println(eventAssignments)
        if let matches = eventAssignments {
            if countElements(matches) > 0 {
                events += "\n<script>\n"
            }
            for match in matches {
                let event = match.groups[2].string
                let function = match.groups[3].string
                let selector = match.groups[1].string
                
                events += "\taddEvent('\(event)', \(function), '\(selector)');\n"
                //functions += " "
                //functions += match.groups[1].string
            }
            if events != "" {
                events += "</script>\n"
            }
        }
        
        result = eraseMatchFromText(result, matches: eventAssignments)
        
        return (result, events)
    }
    
    // =======================================================
    // MARK: functions that replace directly
    
    /// :returns: the text with replaced links. Twine -> HTML
    class func replaceTwineOccurencesByHTMLLinks(text:String) -> String {
        // for twine links [[link]], use \[\[(\w+)\|?(\w+)?\]\[?([^\]]+)?\]?\]
        
        var result = text
        let expression = "\\[\\[(\\w+)\\|?(\\w+)?\\]\\[?([^\\]]+)?\\]?\\]"
        let replacement = "<a href=\"$2\">$1</a><script>$3</script>"
        result = result.stringByReplacingOccurrencesOfString(expression, withString: replacement, options: NSStringCompareOptions.RegularExpressionSearch, range: Range(start: result.startIndex, end: result.endIndex))
        
        return result
    }
    
    /// Insert javascript calls in a <script> tag
    ///
    /// :returns: the text with replaced function calls
    class func replaceFunctionCalls(text:String) -> String {
        // for function calls, use (?:(?<=\n)|(?<=\A))(\w+\([^\)]+\); ?(?://.*?)?)(?:(?=\n)|(?=\Z))
        
        var result = text
        let expression = "(?:(?<=\\n)|(?<=\\A))(\\w+\\([^\\)]*\\); ?(?://.*?)?)(?:(?=\\n)|(?=\\Z))"
        // FIXME: markdown erases line breaks. Might not be any way to avoid it, maybe just let it be.. ?
        let replacement = "<script>\n\t$1\n</script>\n"
        result = result.stringByReplacingOccurrencesOfString(expression, withString: replacement, options: NSStringCompareOptions.RegularExpressionSearch, range: Range(start: result.startIndex, end: result.endIndex))
        return result
    }
    
    class func replaceComments(text:String) -> String {
        // for comments, use (?:(?<=\n)|(?<=\A))//([^\n]*)
        var result = text
        
        let expression = "(?:(?<=\\n)|(?<=\\A))//([^\\n]*)"
        let replacement = "<!-- $1 -->"
        result = result.stringByReplacingOccurrencesOfString(expression, withString: replacement, options: NSStringCompareOptions.RegularExpressionSearch, range: Range(start: result.startIndex, end: result.endIndex))
        
        return result
    }
    
    // the pair must be two Strings
    // replaces pair.a with pair.b
    class func replacePairInText(pair:Pair, inText text:String) -> String {
        var result = text
        
        var oldString = pair.a as? String
        var newString = pair.b as? String
        if oldString == nil || newString == nil {
            println("The pair is not a pair of strings, no change has been made")
            return text
        }
        
        result = result.stringByReplacingOccurrencesOfString(oldString!, withString: newString!, options: NSStringCompareOptions.LiteralSearch, range: Range(start: result.startIndex, end: result.endIndex))
        
        return result
    }
    
    // =======================================================
    // MARK: functions that find pairs of braces
    
    class func completeTokenForJavascriptFunction(openingBraceToken:Token, inText text:String) -> Token? {
    //class func findEndOfBraceForJavascriptFunction(brace:Token, inText text:String) -> Token? {
        let functionStartIndex = advance(text.startIndex, openingBraceToken.range.location)
        let braceIntIndex = openingBraceToken.range.location + openingBraceToken.range.length
        let braceIndex = advance(text.startIndex, braceIntIndex)
        var index = braceIndex
        var nested = 0 // keeps track of nested brace we find
        
        // found all { and }
        let searchRange = NSMakeRange(braceIntIndex, countElements(text) - braceIntIndex)
        // TODO: add the possibility to capture a commentary at the end of the function
        var braces = getOccurencesOfRegularExpression("\\{|(?:\\}(?:(?=\\n)|(?=\\Z)))", inString: text, withRange: searchRange)
        
        var which = 0
        var match:RegexMatch?
        if let actualBraces = braces {
            for brace in actualBraces {
                if brace.groups[0].string == "{" {
                    which++
                } else {
                    if which == 0 {
                        match = brace
                        break
                    } else {
                        which--
                    }
                }
            }
        }
        
        if let actualMatch = match {
            let loc = actualMatch.groups[0].range.location
            let len = actualMatch.groups[0].range.length
            let functionEndIndex = advance(text.startIndex, loc + len)
            let tokString = text.substringWithRange(Range(start:functionStartIndex, end:functionEndIndex))
            let rangeLoc = openingBraceToken.range.location
            let rangeLen = distance(functionStartIndex, functionEndIndex)
            let tok = Token(_string: tokString, _range: NSMakeRange(rangeLoc, rangeLen))
            return tok
        }
        
        return nil

    }
    
    class func convertIdsAndClasses(text:String) -> String {
        
        var result = text
        
        // opening ids and classes inline       (?<= )([#\.])([^.# ]+)\{
        // closing ids and classes inline       (?<!\n)\}(?:<([^>\n]+?)>)?[:punct:]*?(?!(\Z|\n))
        
        var inlineIdsAndClasses = getOccurencesOfRegularExpression("(?<= )([#\\.])([^.# ]+)\\{\\{", inString: text)
        var inlineClosingIdsAndClasses = getOccurencesOfRegularExpression("(?<!\\n)\\}\\}(?:<([^>\\n]+?)>)?[:punct:]*?(?!(\\Z|\\n))", inString: text)
        //println("ids and classes inlines: \(inlineIdsAndClasses)\n")
        //println("--------------------")
        //println("ids and classes closing inlines: \(inlineClosingIdsAndClasses)\n")
        //println("--------------------")
        
        // opening ids and classes in blocks    (?:(?<=\n)|(?<=\A))([#\.])([^.# ]+)\{
        // closing ids and classes in blocks    \}(?:<(.*?)>)?(?:(?=\n)|(?=\Z))
        
        var blockIdsAndClasses = getOccurencesOfRegularExpression("(?:(?<=\\n)|(?<=\\A))([#\\.])([^.# ]+)\\{\\{", inString: text)
        var blockClosingIdsAndClasses = getOccurencesOfRegularExpression("\\}\\}(?:<(.*?)>)?(?:(?=\\n)|(?=\\Z))", inString: text)
        //println("ids and classes blocks: \(blockIdsAndClasses)\n")
        //println("--------------------")
        //println("ids and classes closing blocks: \(blockClosingIdsAndClasses)\n")
        //println("--------------------")
        
        // create a list with all the opening and closing tags
        var tagMatches = [TagMatch]()
        var openingCount = 0
        var closingCount = 0
        if let inlineOpenings = inlineIdsAndClasses {
            for match in inlineOpenings {
                tagMatches += [TagMatch(matchType: MatchType.INLINE, tokens: match.groups)]
                openingCount++
            }
        }
        if let inlineClosings = inlineClosingIdsAndClasses {
            for match in inlineClosings {
                tagMatches += [TagMatch(matchType: MatchType.INLINE, tokens: match.groups)]
                closingCount++
            }
        }
        if let blockOpenings = blockIdsAndClasses {
            for match in blockOpenings {
                tagMatches += [TagMatch(matchType: MatchType.BLOCK, tokens: match.groups)]
                openingCount++
            }
        }
        if let blockClosings = blockClosingIdsAndClasses {
            for match in blockClosings {
                tagMatches += [TagMatch(matchType: MatchType.BLOCK, tokens: match.groups)]
                closingCount++
            }
        }
        
        // unable to make pairs
        if (openingCount != closingCount) {
            println("There's a different amount of opening and closing tags. There must be an error somewhere.")
            return text
        }
        
        // sort them in the order they appear inside the text
        tagMatches.sort({$0.groups[0].range.location < $1.groups[0].range.location})
        //println(tagMatches)
        
        // error with first tag
        if tagMatches[0].position == MatchPosition.CLOSING {
            println("the first tag match should be an opening tag. There's an error in the file.")
            return text
        }
        
        // make pairs
        var pairs = [Pair]()
        
        // the pairs are added in the list with the order outside first, inside last
        var safeKeeper = 0
        while(countElements(tagMatches) > 1) {
            var nestLevel = 0
            var openingIndex = 0
            for var i = 1; i < countElements(tagMatches); i++ {
                if tagMatches[i].position == MatchPosition.OPENING {
                    nestLevel++
                    continue
                } else {
                    if nestLevel > 0 {
                        nestLevel--
                    } else {
                        // we found the right closing tagMatch
                        pairs += [Pair(_a: tagMatches[openingIndex], _b: tagMatches[i])]
                        tagMatches.removeAtIndex(i)
                        tagMatches.removeAtIndex(openingIndex)
                        openingIndex = i - 1
                        i--
                    }
                }
            }
            
            // FIXME: the safekeeper create a max nesting of 10 levels. Not good to block this, but important to check if the while loop is safe.
            safeKeeper++
            if safeKeeper > 10 {
                println("more than 10 level of nesting curly braces, might be a bug in the while loop?")
                break
            }
        }
        
        let stringPairs = getPairsOfStringsToReplaceWithMatchPairs(pairs, forText: text)
        for stringPair in stringPairs {
            result = replacePairInText(stringPair, inText: result)
        }
        
        return result
    }
    
    class func getPairsOfStringsToReplaceWithMatchPairs(matchPairs:[Pair], forText text:String) -> [Pair] {
        var pairs = [Pair]()
        
        for pair in matchPairs {
            pairs += [getPairOfStringsFromMatchPair(pair, forText: text)]
        }
        
        return pairs
    }
    
    class func getPairOfStringsFromMatchPair(matchPair:Pair, forText text:String) -> Pair {
        
        var openingMatch = matchPair.a as? TagMatch
        var closingMatch = matchPair.b as? TagMatch
        if openingMatch == nil || closingMatch == nil {
            println("pair has not the right type of object... no change has been made")
            return Pair(_a: "", _b: "")
        }
        
        var tag = "div"
        if openingMatch!.type == MatchType.INLINE || closingMatch!.type == MatchType.INLINE {
            tag = "span"
        }
        var type = "id"
        if openingMatch!.groups[1].string == "." {
            type = "class"
        }
        var name = openingMatch!.groups[2].string
        
        var function = closingMatch!.groups[1].string
        if function != "" {
            function = " \(function)"
        }
        
        var openingTag = "<\(tag) \(type)=\"\(name)\"\(function)>"
        var closingTag = "</\(tag)>"
        if tag == "div" {
            openingTag += "\n\t"
            closingTag = "\n"+closingTag
        }
        
        var originalStringStartIndex = advance(text.startIndex, openingMatch!.groups[0].range.location)
        var originalStringEndIndex = advance(text.startIndex, closingMatch!.groups[0].range.location+closingMatch!.groups[0].range.length)
        var originalString = text.substringWithRange(Range(start: originalStringStartIndex, end: originalStringEndIndex))
        
        var newStringStartIndex = advance(text.startIndex, openingMatch!.groups[0].range.location+openingMatch!.groups[0].range.length)
        var newStringEndIndex = advance(text.startIndex, closingMatch!.groups[0].range.location)
        var newString = text.substringWithRange(Range(start: newStringStartIndex, end: newStringEndIndex))
        newString = "\(openingTag)\(newString)\(closingTag)"
        
        return Pair(_a: originalString, _b: newString)
    }
    
}